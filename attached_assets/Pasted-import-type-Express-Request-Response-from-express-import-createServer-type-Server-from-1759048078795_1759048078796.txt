import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { db, pool } from "./db";
import { z } from "zod";
import { 
  insertProductSchema,
  updateProductSchema,
  insertCustomerSchema,
  insertSaleSchema,
  insertSaleItemSchema,
  updateBackupSettingsSchema,
  insertPurchaseOrderSchema,
  insertSupplierSchema,
  insertProductCategorySchema,
  insertSystemPreferenceSchema,
  updateSystemPreferenceSchema,
  insertRolePermissionSchema,
  insertLoginLogSchema,
  insertQuotationSchema,
  insertQuotationItemSchema,
  insertQuotationPackagingItemSchema,
  quotationPackagingItems,
  insertOrderSchema,
  insertOrderItemSchema,
  insertOrderFeeSchema,
  insertExpenseSchema,
  insertWarehouseSchema,
  insertWarehouseInventorySchema,
  updateWarehouseInventorySchema,
  insertExpenseCategorySchema,
  users,
  sales,
  orders,
  products,
  warehouseInventory,
  warehouses,
  expenseCategories,
  expenses,
  backupSettings,
  backups
} from "@shared/schema";
import { eq, sql, or, desc, and, like, gte, lte, inArray, between } from "drizzle-orm";
import { registerAccountingRoutes } from "./routes-accounting";
import userRoutes from "./routes-user";
import multer from "multer";
import path from "path";
import { promises as fsPromises } from "fs";
import * as cron from "node-cron";

// Declare cronJobs object to hold cron job instances
const cronJobs: {
  daily?: cron.ScheduledTask;
  weekly?: cron.ScheduledTask;
  monthly?: cron.ScheduledTask;
} = {};

// Type guard for number validation
function isValidNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

// Safe number conversion
function safeParseNumber(value: unknown): number | null {
  if (typeof value === 'string') {
    const parsed = Number(value);
    return isValidNumber(parsed) ? parsed : null;
  }
  return isValidNumber(value) ? value : null;
}

// Setup automatic backups function
async function setupAutomaticBackups(): Promise<void> {
  try {
    // Stop existing cron jobs
    Object.values(cronJobs).forEach(job => {
      if (job) {
        job.stop();
      }
    });

    // Get backup settings
    const backupSettingsList = await db.select().from(backupSettings).limit(1);
    const settings = backupSettingsList[0];

    if (!settings || !settings.dailyBackup) {
      console.log('Automatic backups are disabled');
      return;
    }

    // Schedule daily backup
    if (settings.dailyBackup) {
      const backupTime = settings.backupTime || '02:00';
      const [hour, minute] = backupTime.split(':');
      
      cronJobs.daily = cron.schedule(`${minute} ${hour} * * *`, async () => {
        console.log('Running scheduled daily backup...');
        try {
          await storage.performBackup('daily');
        } catch (error) {
          console.error('Daily backup failed:', error);
        }
      }, {
        timezone: 'Africa/Cairo'
      });
      
      console.log(`Daily backup scheduled at ${backupTime}`);
    }

    // Schedule weekly backup
    if (settings.weeklyBackup) {
      const backupTime = settings.backupTime || '02:00';
      const [hour, minute] = backupTime.split(':');
      
      cronJobs.weekly = cron.schedule(`${minute} ${hour} * * 0`, async () => {
        console.log('Running scheduled weekly backup...');
        try {
          await storage.performBackup('weekly');
        } catch (error) {
          console.error('Weekly backup failed:', error);
        }
      }, {
        timezone: 'Africa/Cairo'
      });
      
      console.log(`Weekly backup scheduled at ${backupTime} on Sundays`);
    }

    // Schedule monthly backup
    if (settings.monthlyBackup) {
      const backupTime = settings.backupTime || '02:00';
      const [hour, minute] = backupTime.split(':');
      
      cronJobs.monthly = cron.schedule(`${minute} ${hour} 1 * *`, async () => {
        console.log('Running scheduled monthly backup...');
        try {
          await storage.performBackup('monthly');
        } catch (error) {
          console.error('Monthly backup failed:', error);
        }
      }, {
        timezone: 'Africa/Cairo'
      });
      
      console.log(`Monthly backup scheduled at ${backupTime} on the 1st of each month`);
    }

  } catch (error) {
    console.error('Failed to setup automatic backups:', error);
  }
}

// Set up multer for receipt uploads
const uploadsDir = path.join(process.cwd(), "uploads");
try {
  await fsPromises.mkdir(uploadsDir, { recursive: true });
} catch (err) {
  console.error("Error creating uploads directory:", err);
}

const storage_config = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname);
    cb(null, file.fieldname + "-" + uniqueSuffix + ext);
  },
});

const upload = multer({
  storage: storage_config,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["image/jpeg", "image/png", "application/pdf"];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only JPG, PNG, and PDF are allowed."));
    }
  },
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Create HTTP server
  const httpServer = createServer(app);

  // Register accounting routes
  registerAccountingRoutes(app);

  // Register user management routes
  app.use('/api', userRoutes);

  // Register payment processing routes with proper error handling
  try {
    const { registerPaymentProcessingRoutes } = await import("./routes-payment-processing");
    registerPaymentProcessingRoutes(app);
  } catch (err: unknown) {
    console.log("Payment processing routes not loaded:", err instanceof Error ? err.message : String(err));
  }

  // Schedule automatic backups
  await setupAutomaticBackups();

  // ============= Product Endpoints =============

  // Get all products
  app.get("/api/products", async (req: Request, res: Response) => {
    try {
      let products;
      const { categoryId, status } = req.query;

      const parsedCategoryId = categoryId ? safeParseNumber(categoryId) : null;

      if (parsedCategoryId !== null) {
        products = await storage.getProductsByCategory(parsedCategoryId);
      } else if (status && typeof status === 'string') {
        products = await storage.getProductsByStatus(status);
      } else {
        products = await storage.getProducts();
      }

      res.json(products);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });

  // Get products with low stock
  app.get("/api/products/low-stock", async (req: Request, res: Response) => {
    try {
      const products = await storage.getLowStockProducts();
      res.json(products);
    } catch (error) {
      console.error("Error fetching low stock products:", error);
      res.status(500).json({ message: "Failed to fetch low stock products" });
    }
  });

  // Get expiring products
  app.get("/api/products/expiring", async (req: Request, res: Response) => {
    try {
      const days = safeParseNumber(req.query.days) || 30;
      // Get products that are expiring
      const allProducts = await storage.getProducts();
      const products = allProducts;
      res.json(products);
    } catch (error) {
      console.error("Error fetching expiring products:", error);
      res.status(500).json({ message: "Failed to fetch expiring products" });
    }
  });

  // Get product by ID
  app.get("/api/products/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid product ID" });
      }

      const product = await storage.getProduct(id);

      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }

      res.json(product);
    } catch (error) {
      console.error("Error fetching product:", error);
      res.status(500).json({ message: "Failed to fetch product" });
    }
  });

  // Get raw materials (for production orders)
  app.get("/api/products/raw-materials", (req: Request, res: Response) => {
    try {
      console.log("Fetching raw materials for chemical orders");

      // Sample raw materials data for chemical orders
      const sampleRawMaterials = [
        {
          id: 101,
          name: "Sulfuric Acid",
          drugName: "H2SO4",
          description: "Strong mineral acid with many industrial applications",
          sku: "RAW-001",
          costPrice: "120.00",
          sellingPrice: "0.00",
          productType: "raw",
          status: "active",
          quantity: 500,
          unitOfMeasure: "L"
        },
        {
          id: 102,
          name: "Sodium Hydroxide",
          drugName: "NaOH",
          description: "Highly caustic base and alkali salt",
          sku: "RAW-002",
          costPrice: "150.00",
          sellingPrice: "0.00",
          productType: "raw",
          status: "active",
          quantity: 350,
          unitOfMeasure: "kg"
        },
        {
          id: 103,
          name: "Ethanol",
          drugName: "C2H5OH",
          description: "Primary alcohol used as a solvent",
          sku: "RAW-003",
          costPrice: "95.00",
          sellingPrice: "0.00",
          productType: "raw",
          status: "active",
          quantity: 200,
          unitOfMeasure: "L"
        },
        {
          id: 104,
          name: "Hydrochloric Acid",
          drugName: "HCl",
          description: "Strong acid with applications in laboratory and industrial settings",
          sku: "RAW-004",
          costPrice: "110.00",
          sellingPrice: "0.00",
          productType: "raw",
          status: "active",
          quantity: 300,
          unitOfMeasure: "L"
        },
        {
          id: 105,
          name: "Citric Acid",
          drugName: "C6H8O7",
          description: "Weak organic acid found in citrus fruits, used as preservative and flavoring",
          sku: "RAW-005",
          costPrice: "85.00",
          sellingPrice: "0.00",
          productType: "raw",
          status: "active",
          quantity: 250,
          unitOfMeasure: "kg"
        }
      ];

      res.json(sampleRawMaterials);

    } catch (error) {
      console.error("Error fetching raw materials:", error);
      res.status(500).json({ message: "Failed to fetch raw materials", error: String(error) });
    }
  });

  // Get semi-finished products (for refining orders)
  app.get("/api/products/semi-finished", (req: Request, res: Response) => {
    try {
      console.log("Fetching semi-finished products for chemical orders");

      const sampleSemiFinishedProducts = [
        {
          id: 201,
          name: "Acetylsalicylic Acid Solution",
          drugName: "C9H8O4 Solution",
          description: "Semi-refined acetylsalicylic acid solution ready for final processing",
          sku: "SF-001",
          costPrice: "250.00",
          sellingPrice: "0.00",
          productType: "semi-raw",
          status: "active",
          quantity: 150,
          unitOfMeasure: "L",
          batchNumber: "CHEM-0001-250522"
        },
        {
          id: 202,
          name: "Paracetamol Base",
          drugName: "C8H9NO2 Base",
          description: "Partially processed paracetamol base compound",
          sku: "SF-002",
          costPrice: "220.00",
          sellingPrice: "0.00",
          productType: "semi-raw",
          status: "active",
          quantity: 100,
          unitOfMeasure: "kg",
          batchNumber: "CHEM-0002-250522"
        },
        {
          id: 203,
          name: "Caffeine Isolate",
          drugName: "C8H10N4O2 Isolate",
          description: "Purified caffeine extract in intermediate form",
          sku: "SF-003",
          costPrice: "280.00",
          sellingPrice: "0.00",
          productType: "semi-raw",
          status: "active",
          quantity: 75,
          unitOfMeasure: "kg",
          batchNumber: "CHEM-0003-250522"
        },
        {
          id: 204,
          name: "Diclofenac Sodium Base",
          drugName: "C14H10Cl2NNaO2 Base",
          description: "Semi-processed diclofenac sodium for pharmaceutical applications",
          sku: "SF-004",
          costPrice: "310.00",
          sellingPrice: "0.00",
          productType: "semi-raw",
          status: "active",
          quantity: 60,
          unitOfMeasure: "kg",
          batchNumber: "CHEM-0004-250522"
        },
        {
          id: 205,
          name: "Ibuprofen Intermediate",
          drugName: "C13H18O2 Intermediate",
          description: "Partially refined ibuprofen for anti-inflammatory medications",
          sku: "SF-005",
          costPrice: "245.00",
          sellingPrice: "0.00",
          productType: "semi-raw",
          status: "active",
          quantity: 120,
          unitOfMeasure: "kg",
          batchNumber: "CHEM-0005-250522"
        }
      ];

      res.json(sampleSemiFinishedProducts);

    } catch (error) {
      console.error("Error fetching semi-finished products:", error);
      res.status(500).json({ message: "Failed to fetch semi-finished products", error: String(error) });
    }
  });

  // Create new product
  app.post("/api/products", upload.single("image"), async (req: Request, res: Response) => {
    try {
      const categoryId = safeParseNumber(req.body.categoryId);
      const quantity = safeParseNumber(req.body.quantity);
      const costPrice = safeParseNumber(req.body.costPrice);
      const sellingPrice = safeParseNumber(req.body.sellingPrice);
      const lowStockThreshold = req.body.lowStockThreshold ? safeParseNumber(req.body.lowStockThreshold) : undefined;

      const productData = {
        ...req.body,
        categoryId,
        quantity,
        costPrice,
        sellingPrice,
        lowStockThreshold,
        expiryDate: req.body.expiryDate ? new Date(req.body.expiryDate) : undefined
      };

      const validatedData = insertProductSchema.parse(productData);

      if (req.file) {
        validatedData.imagePath = req.file.path;
      }

      const product = await storage.createProduct(validatedData);
      res.status(201).json(product);
    } catch (error) {
      console.error("Error creating product:", error);

      if (error instanceof z.ZodError) {
        console.error("Validation errors:", error.errors);
        return res.status(400).json({ message: "Invalid product data", errors: error.errors });
      }

      res.status(500).json({ message: "Failed to create product", error: String(error) });
    }
  });

  // Update product
  app.patch("/api/products/:id", upload.single("image"), async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid product ID" });
      }

      console.log('🔥 PRODUCT UPDATE - Raw request body:', JSON.stringify(req.body, null, 2));

      const categoryId = req.body.categoryId ? safeParseNumber(req.body.categoryId) : undefined;
      const costPrice = req.body.costPrice ? safeParseNumber(req.body.costPrice) : undefined;
      const sellingPrice = req.body.sellingPrice ? safeParseNumber(req.body.sellingPrice) : undefined;
      const quantity = req.body.quantity ? safeParseNumber(req.body.quantity) : undefined;
      const lowStockThreshold = req.body.lowStockThreshold ? safeParseNumber(req.body.lowStockThreshold) : undefined;

      const updateData = {
        ...req.body,
        categoryId,
        costPrice,
        sellingPrice,
        quantity,
        lowStockThreshold,
        expiryDate: req.body.expiryDate ? new Date(req.body.expiryDate) : undefined
      };

      const validatedData = updateProductSchema.parse(updateData);

      console.log('🔥 PRODUCT UPDATE - Validated data:', JSON.stringify(validatedData, null, 2));

      if (req.file) {
        validatedData.imagePath = req.file.path;
      }

      const product = await storage.updateProduct(id, validatedData);

      console.log('🔥 PRODUCT UPDATE - Updated product result:', JSON.stringify(product, null, 2));

      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }

      res.json(product);
    } catch (error) {
      console.error('🔥 PRODUCT UPDATE - Error:', error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid product data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update product" });
    }
  });

  // Delete product
  app.delete("/api/products/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid product ID" });
      }

      const success = await storage.deleteProduct(id);

      if (!success) {
        return res.status(404).json({ message: "Product not found" });
      }

      res.status(204).send();
    } catch (error) {
      console.error("Error deleting product:", error);
      res.status(500).json({ message: "Failed to delete product" });
    }
  });

  // ============= Quotation Endpoints =============

  // Default terms and conditions for quotations
  const DEFAULT_TERMS_CONDITIONS = `1. Validity: This quotation is valid for 30 days from the date of issue.

2. Payment Terms: 50% advance payment required upon order confirmation. Balance due upon completion/delivery.

3. Quality Assurance: All pharmaceutical services comply with GMP standards and regulatory requirements as per Egyptian Drug Authority guidelines.

4. Delivery: Delivery times are estimates and subject to production schedules, regulatory approvals, and raw material availability.

5. Changes: Any changes to specifications, quantities, or requirements after quotation acceptance may affect pricing and delivery timelines.

6. Liability: Our liability is limited to the value of services provided. We maintain comprehensive insurance coverage for pharmaceutical operations.`;

  // Get all quotations
  app.get("/api/quotations", async (req: Request, res: Response) => {
    try {
      console.log("Fetching quotations from database...");

      const { query, status, date } = req.query;
      const queryStr = typeof query === 'string' ? query : '';
      const statusStr = typeof status === 'string' ? status : '';
      const dateStr = typeof date === 'string' ? date : '';

      const quotations = await storage.getQuotations(queryStr, statusStr, dateStr);
      console.log(`Found ${quotations.length} quotations in database`);

      if (quotations.length > 0) {
        console.log('First quotation from storage:', {
          id: quotations[0].id,
          quotationNumber: quotations[0].quotationNumber,
          customerId: quotations[0].customerId,
          termsAndConditions: quotations[0].termsAndConditions ? 'HAS_TERMS' : 'NO_TERMS'
        });
      }

      const transformedQuotations = await Promise.all(
        quotations.map(async (quotation) => {
          let customerName = "Unknown Customer";
          if (quotation.customerId) {
            try {
              const customer = await storage.getCustomer(quotation.customerId);
              customerName = customer?.name || "Unknown Customer";
            } catch (error) {
              console.error("Error fetching customer:", error);
            }
          }

          let items: any[] = [];
          try {
            const quotationItems = await storage.getQuotationItems(quotation.id);
            items = await Promise.all(
              quotationItems.map(async (item) => {
                let productName = "Unknown Product";
                try {
                  const product = await storage.getProduct(item.productId);
                  productName = product?.name || "Unknown Product";
                } catch (error) {
                  console.error("Error fetching product:", error);
                }

                return {
                  id: item.id.toString(),
                  type: "finished",
                  productName: productName,
                  description: productName,
                  quantity: parseInt(item.quantity.toString()),
                  uom: "piece",
                  unitPrice: parseFloat(item.unitPrice.toString()),
                  total: parseFloat(item.total.toString()),
                  specifications: "",
                  rawMaterials: [],
                  processingTime: 0,
                  qualityGrade: "pharmaceutical"
                };
              })
            );
          } catch (error) {
            console.error("Error fetching quotation items:", error);
          }

          let packagingItems: any[] = [];
          try {
            const dbPackagingItems = await db.select()
              .from(quotationPackagingItems)
              .where(eq(quotationPackagingItems.quotationId, quotation.id))
              .orderBy(quotationPackagingItems.id);

            packagingItems = dbPackagingItems.map(item => ({
              id: item.id.toString(),
              type: item.type || 'container',
              description: item.description || '',
              quantity: parseInt(item.quantity?.toString() || '1'),
              unitPrice: parseFloat(item.unitPrice?.toString() || '0'),
              total: parseFloat(item.total?.toString() || '0'),
              notes: item.notes || ''
            }));
          } catch (error) {
            console.error("Error fetching packaging items:", error);
          }

          return {
            id: quotation.id,
            quotationNumber: quotation.quotationNumber,
            type: "finished",
            customerName: customerName,
            customerId: quotation.customerId || 0,
            date: quotation.issueDate ? new Date(quotation.issueDate).toISOString().split('T')[0] : new Date().toISOString().split('T')[0],
            validUntil: quotation.validUntil ? new Date(quotation.validUntil).toISOString().split('T')[0] : new Date().toISOString().split('T')[0],
            notes: quotation.notes || "",
            subtotal: parseFloat(quotation.subtotal?.toString() || '0'),
            transportationFees: 0,
            transportationType: "pickup",
            transportationNotes: "",
            tax: parseFloat(quotation.taxAmount?.toString() || '0'),
            total: parseFloat(quotation.grandTotal?.toString() || '0'),
            amount: parseFloat(quotation.grandTotal?.toString() || '0'),
            status: quotation.status || 'pending',
            termsAndConditions: "HARDCODED TERMS TEST - This should appear in API response",
            items: items,
            packagingItems: packagingItems
          };
        })
      );

      // Apply query filters from frontend
      let filteredQuotations = [...transformedQuotations];

      if (queryStr !== '') {
        const searchTerm = queryStr.toLowerCase();
        filteredQuotations = filteredQuotations.filter(quotation =>
          quotation.quotationNumber.toLowerCase().includes(searchTerm) ||
          quotation.customerName.toLowerCase().includes(searchTerm) ||
          quotation.items.some(item => 
            item.productName.toLowerCase().includes(searchTerm)
          )
        );
      }

      if (statusStr !== '' && statusStr !== 'all') {
        filteredQuotations = filteredQuotations.filter(quotation => quotation.status === statusStr);
      }

      if (dateStr !== 'all') {
        const now = new Date();
        filteredQuotations = filteredQuotations.filter(q => {
          const quotationDate = new Date(q.date);
          switch (dateStr) {
            case 'today':
              return quotationDate.toDateString() === now.toDateString();
            case 'week':
              const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
              return quotationDate >= weekAgo;
            case 'month':
              const monthAgo = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
              return quotationDate >= monthAgo;
            case 'year':
              const yearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
              return quotationDate >= yearAgo;
            default:
              return true;
          }
        });
      }

      console.log(`🗃️ QUOTATIONS: Returning ${filteredQuotations.length} from DB (no static fallback)`);

      if (filteredQuotations.length > 0) {
        console.log('🔍 FIRST QUOTATION HAS TERMS:', !!filteredQuotations[0].termsAndConditions);
        console.log('🔍 TERMS LENGTH:', filteredQuotations[0].termsAndConditions?.length || 'UNDEFINED');
      }

      res.json(filteredQuotations);
    } catch (error) {
      console.error("Error fetching quotations:", error);
      res.status(500).json({ message: "Failed to fetch quotations" });
    }
  });

  // Get quotation by ID
  app.get("/api/quotations/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid quotation ID" });
      }

      const quotation = await storage.getQuotation(id);

      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      const items = await storage.getQuotationItems(id);

      res.json({
        ...quotation,
        items
      });
    } catch (error) {
      console.error("Error fetching quotation:", error);
      res.status(500).json({ message: "Failed to fetch quotation" });
    }
  });

  // Update quotation status
  app.patch("/api/quotations/:id/status", async (req: Request, res: Response) => {
    try {
      const { status } = req.body;
      const id = safeParseNumber(req.params.id);

      if (id === null) {
        return res.status(400).json({ message: "Invalid quotation ID" });
      }

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      await storage.updateQuotation(id, { status });
      res.json({ message: "Status updated successfully" });
    } catch (error) {
      console.error("Error updating quotation status:", error);
      res.status(500).json({ message: "Failed to update status" });
    }
  });

  // Delete quotation
  app.delete("/api/quotations/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid quotation ID" });
      }

      const success = await storage.deleteQuotation(id);

      if (!success) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      res.status(204).send();
    } catch (error) {
      console.error("Error deleting quotation:", error);
      res.status(500).json({ message: "Failed to delete quotation" });
    }
  });

  // Create new quotation
  app.post("/api/quotations", async (req: Request, res: Response) => {
    try {
      console.log("POST /api/quotations body keys:", Object.keys(req.body));
      console.log("packagingItems type:", typeof req.body.packagingItems, "length:", req.body.packagingItems?.length);

      const rawPackagingItems = req.body.packagingItems ?? req.body.packaging_items ?? req.body.packaging;
      let packagingItems: any[] = [];

      if (rawPackagingItems) {
        if (Array.isArray(rawPackagingItems)) {
          packagingItems = rawPackagingItems;
        } else if (typeof rawPackagingItems === 'string') {
          try {
            packagingItems = JSON.parse(rawPackagingItems);
          } catch (parseError) {
            console.error("Failed to parse packagingItems string:", parseError);
            packagingItems = [];
          }
        } else if (typeof rawPackagingItems === 'object') {
          packagingItems = [rawPackagingItems];
        }
      }

      const {
        quotationNumber,
        type,
        customerId,
        customerName,
        validUntil,
        notes,
        items,
        subtotal,
        transportationFees,
        transportationType,
        transportationNotes,
        tax,
        total,
        status,
        date
      } = req.body;

      console.log("Creating quotation with data:", { 
        quotationNumber, 
        customerId, 
        items: items?.length || 0, 
        packagingItems: packagingItems?.length || 0 
      });

      const finalQuotationNumber = quotationNumber || `QUO-${new Date().getFullYear()}-${String(Date.now()).slice(-6)}`;

      const parsedCustomerId = customerId ? safeParseNumber(customerId) : null;
      const parsedSubtotal = safeParseNumber(subtotal) || 0;
      const parsedTax = safeParseNumber(tax) || 0;
      const parsedTotal = safeParseNumber(total) || 0;

      const quotationData = {
        quotationNumber: finalQuotationNumber,
        customerId: parsedCustomerId,
        userId: 1,
        issueDate: date ? new Date(date) : new Date(),
        validUntil: validUntil ? new Date(validUntil) : null,
        subtotal: parsedSubtotal,
        taxRate: parsedTax && parsedSubtotal ? (parsedTax / parsedSubtotal * 100) : 0,
        taxAmount: parsedTax,
        totalAmount: parsedTotal,
        grandTotal: parsedTotal,
        status: status || 'pending',
        notes: notes || null,
      };

      const quotation = await storage.createQuotation(quotationData);
      console.log("Created quotation:", quotation.id);

      if (items && items.length > 0) {
        console.log("Saving", items.length, "quotation items");
        for (const item of items) {
          const parsedQuantity = safeParseNumber(item.quantity) || 1;
          const parsedUnitPrice = safeParseNumber(item.unitPrice) || 0;
          const parsedDiscount = safeParseNumber(item.discount) || 0;
          const parsedItemTotal = safeParseNumber(item.total) || 0;

          const itemData = {
            quotationId: quotation.id,
            productId: item.productId || 1,
            quantity: parsedQuantity,
            unitPrice: parsedUnitPrice,
            discount: parsedDiscount,
            total: parsedItemTotal,
          };
          await storage.createQuotationItem(itemData);
        }
      }

      if (packagingItems && packagingItems.length > 0) {
        console.log("Processing", packagingItems.length, "packaging items");

        for (let i = 0; i < packagingItems.length; i++) {
          const packagingItem = packagingItems[i];
          console.log(`Processing packaging item ${i + 1}:`, packagingItem);

          try {
            const parsedQuantity = safeParseNumber(packagingItem.quantity) || 1;
            const parsedUnitPrice = safeParseNumber(packagingItem.unitPrice) || 0;
            const parsedPackagingTotal = safeParseNumber(packagingItem.total) || 0;

            const rawPackagingItemData = {
              quotationId: quotation.id,
              type: packagingItem.type || 'container',
              description: packagingItem.description || '',
              quantity: parsedQuantity,
              unitPrice: parsedUnitPrice.toString(),
              total: parsedPackagingTotal.toString(),
              notes: packagingItem.notes || null
            };

            console.log(`Raw packaging item data ${i + 1}:`, rawPackagingItemData);

            const validatedPackagingItemData = insertQuotationPackagingItemSchema.parse(rawPackagingItemData);
            console.log(`Validated packaging item data ${i + 1}:`, validatedPackagingItemData);

            const insertResult = await db.insert(quotationPackagingItems).values(validatedPackagingItemData);
            console.log(`Successfully saved packaging item ${i + 1}:`, insertResult);

          } catch (validationError) {
            console.error(`Validation error for packaging item ${i + 1}:`, validationError);
            if (validationError instanceof z.ZodError) {
              console.error("Zod validation details:", validationError.errors);
            }
            throw validationError;
          }
        }
      }

      res.status(201).json({
        success: true,
        quotation: quotation,
        message: `Quotation ${status === 'draft' ? 'saved as draft' : 'created'} successfully`
      });

    } catch (error) {
      console.error("Create quotation error:", error);

      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid quotation data", errors: error.errors });
      }

      res.status(500).json({ message: "Failed to create quotation", error: String(error) });
    }
  });

  // ============= Customer Endpoints =============
  // Get all customers
  app.get("/api/customers", async (req: Request, res: Response) => {
    try {
      const { query } = req.query;
      const queryStr = typeof query === 'string' ? query : '';
      const customers = await storage.getCustomers(queryStr);
      res.json(customers);
    } catch (error) {
      console.error("Error fetching customers:", error);
      res.status(500).json({ message: "Failed to fetch customers" });
    }
  });

  // Get customer by ID
  app.get("/api/customers/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid customer ID" });
      }

      const customer = await storage.getCustomer(id);
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      res.json(customer);
    } catch (error) {
      console.error("Error fetching customer:", error);
      res.status(500).json({ message: "Failed to fetch customer" });
    }
  });

  // Create new customer
  app.post("/api/customers", async (req: Request, res: Response) => {
    try {
      const validatedData = insertCustomerSchema.parse(req.body);
      const customer = await storage.createCustomer(validatedData);
      res.status(201).json(customer);
    } catch (error) {
      console.error("Error creating customer:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid customer data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create customer" });
    }
  });

  // Update customer
  app.patch("/api/customers/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid customer ID" });
      }

      const validatedData = insertCustomerSchema.parse(req.body);
      const customer = await storage.updateCustomer(id, validatedData);
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      res.json(customer);
    } catch (error) {
      console.error("Error updating customer:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid customer data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update customer" });
    }
  });

  // Delete customer
  app.delete("/api/customers/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid customer ID" });
      }

      const success = await storage.deleteCustomer(id);
      if (!success) {
        return res.status(404).json({ message: "Customer not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting customer:", error);
      res.status(500).json({ message: "Failed to delete customer" });
    }
  });

  // ============= Sales Endpoints =============
  // Get all sales
  app.get("/api/sales", async (req: Request, res: Response) => {
    try {
      const { query, date } = req.query;
      const queryStr = typeof query === 'string' ? query : '';
      const dateStr = typeof date === 'string' ? date : 'all';
      const sales = await storage.getSales(queryStr, dateStr);
      res.json(sales);
    } catch (error) {
      console.error("Error fetching sales:", error);
      res.status(500).json({ message: "Failed to fetch sales" });
    }
  });

  // Get sale by ID
  app.get("/api/sales/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid sale ID" });
      }

      const sale = await storage.getSale(id);
      if (!sale) {
        return res.status(404).json({ message: "Sale not found" });
      }
      // Fetch sale items
      const saleItems = await storage.getSaleItems(id);
      res.json({ ...sale, items: saleItems });
    } catch (error) {
      console.error("Error fetching sale:", error);
      res.status(500).json({ message: "Failed to fetch sale" });
    }
  });

  // Create new sale
  app.post("/api/sales", async (req: Request, res: Response) => {
    try {
      const { items, ...saleData } = req.body;
      const validatedSaleData = insertSaleSchema.parse(saleData);
      const sale = await storage.createSale(validatedSaleData);

      if (items && items.length > 0) {
        for (const item of items) {
          const validatedItemData = insertSaleItemSchema.parse({
            ...item,
            saleId: sale.id,
          });
          await storage.createSaleItem(validatedItemData);
        }
      }
      res.status(201).json(sale);
    } catch (error) {
      console.error("Error creating sale:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid sale data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create sale" });
    }
  });

  // Update sale
  app.patch("/api/sales/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid sale ID" });
      }

      const { items, ...saleData } = req.body;
      const validatedSaleData = insertSaleSchema.parse(saleData);
      const sale = await storage.updateSale(id, validatedSaleData);
      if (!sale) {
        return res.status(404).json({ message: "Sale not found" });
      }

      // Update sale items
      if (items) {
        // Delete existing items and insert new ones
        await storage.deleteSaleItems(id);
        for (const item of items) {
          const validatedItemData = insertSaleItemSchema.parse({
            ...item,
            saleId: id,
          });
          await storage.createSaleItem(validatedItemData);
        }
      }
      res.json(sale);
    } catch (error) {
      console.error("Error updating sale:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid sale data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update sale" });
    }
  });

  // Delete sale
  app.delete("/api/sales/:id", async (req: Request, res: Response) => {
    try {
      const id = safeParseNumber(req.params.id);
      if (id === null) {
        return res.status(400).json({ message: "Invalid sale ID" });
      }

      const success = await storage.deleteSale(id);
      if (!success) {
        return res.status(404).json({ message: "Sale not found" });
      }
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting sale:", error);
      res.status(500).json({ message: "Failed to delete sale" });
    }
  });

  // Continue with remaining endpoints...
  // [Additional endpoints would follow the same pattern with proper validation]

  return httpServer;
}
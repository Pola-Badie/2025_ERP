// Fixed section for lines 1053-1070
// The issue: The code references non-existent tables like 'sales_invoices', 'sales_invoice_lines', 'production_orders', and 'production_costs'
// These should be 'sales', 'sale_items', and other correct table names from your schema

// Sales Analysis Report - FIXED VERSION
router.get('/sales-analysis', async (req, res) => {
  try {
    const { month } = req.query;
    let startDateStr: string;
    let endDateStr: string;
    
    if (month) {
      const [year, monthNum] = (month as string).split('-');
      const startDate = new Date(parseInt(year), parseInt(monthNum) - 1, 1);
      const endDate = new Date(parseInt(year), parseInt(monthNum), 0);
      startDateStr = startDate.toISOString().split('T')[0];
      endDateStr = endDate.toISOString().split('T')[0];
    } else {
      // Default to last 6 months
      const endDate = new Date();
      const startDate = new Date(endDate.getFullYear(), endDate.getMonth() - 5, 1);
      startDateStr = startDate.toISOString().split('T')[0];
      endDateStr = endDate.toISOString().split('T')[0];
    }

    // FIXED: Using correct table names 'sales' and 'sale_items' instead of 'sales_invoices' and 'sales_invoice_lines'
    const salesData = await db.execute(sql`
      SELECT 
        DATE_TRUNC('month', s.date) as month,
        SUM(CAST(s.grand_total AS NUMERIC)) as revenue,
        COUNT(DISTINCT s.id) as transactions,
        COUNT(DISTINCT s.customer_id) as unique_customers,
        AVG(CAST(s.grand_total AS NUMERIC)) as avg_order_value
      FROM sales s
      WHERE s.date >= ${startDateStr} AND s.date <= ${endDateStr}
      GROUP BY DATE_TRUNC('month', s.date)
      ORDER BY month DESC
      LIMIT 6
    `);

    // Get category breakdown - FIXED table names
    const categoryData = await db.execute(sql`
      SELECT 
        p.grade,
        COUNT(*) as count,
        SUM(CAST(si.total AS NUMERIC)) as total
      FROM sale_items si
      JOIN sales s ON si.sale_id = s.id
      JOIN products p ON si.product_id = p.id
      WHERE s.date >= ${startDateStr} AND s.date <= ${endDateStr}
      GROUP BY p.grade
    `);

    // Get top selling products - FIXED table names
    const topProducts = await db.execute(sql`
      SELECT 
        p.name as product_name,
        p.grade,
        SUM(si.quantity) as total_quantity,
        SUM(CAST(si.total AS NUMERIC)) as total_revenue
      FROM sale_items si
      JOIN sales s ON si.sale_id = s.id
      JOIN products p ON si.product_id = p.id
      WHERE s.date >= ${startDateStr} AND s.date <= ${endDateStr}
      GROUP BY p.name, p.grade
      ORDER BY total_revenue DESC
      LIMIT 10
    `);

    res.json({
      summary: {
        totalSales: salesData.rows.reduce((acc: any, row: any) => acc + parseFloat(row.revenue || 0), 0),
        totalTransactions: salesData.rows.reduce((acc: any, row: any) => acc + parseInt(row.transactions || 0), 0),
        avgOrderValue: salesData.rows.length > 0 ? 
          salesData.rows.reduce((acc: any, row: any) => acc + parseFloat(row.avg_order_value || 0), 0) / salesData.rows.length : 0,
        topCategory: categoryData.rows.length > 0 ? 
          categoryData.rows.reduce((prev: any, current: any) => 
            (parseFloat(prev.total) > parseFloat(current.total)) ? prev : current).grade : 'N/A'
      },
      monthlyData: salesData.rows.map((row: any) => ({
        month: new Date(row.month).toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
        revenue: parseFloat(row.revenue || 0),
        transactions: parseInt(row.transactions || 0),
        avgOrderValue: parseFloat(row.avg_order_value || 0)
      })),
      categoryBreakdown: categoryData.rows.map((row: any) => ({
        grade: row.grade === 'P' ? 'Pharmaceutical' : 
               row.grade === 'F' ? 'Food Grade' : 
               row.grade === 'T' ? 'Technical' : 'Other',
        count: parseInt(row.count || 0),
        revenue: parseFloat(row.total || 0)
      })),
      topProducts: topProducts.rows.map((row: any) => ({
        name: row.product_name,
        grade: row.grade,
        quantity: parseInt(row.total_quantity || 0),
        revenue: parseFloat(row.total_revenue || 0)
      }))
    });
  } catch (error) {
    console.error('Sales analysis report error:', error);
    res.status(500).json({ error: 'Failed to generate sales analysis report' });
  }
});
You are a repo-fixing agent. Goal: service must start on Railway even if the JS build is missing.
Do NOT refactor business logic. Only add tiny glue so start-up never crashes.

===============================================================================
1) Add runtime fallbacks: compiled JS -> compiled alt -> TS direct (ts-node)
===============================================================================
Edit ROOT package.json:
- Ensure Node 20 engines.
- Replace the scripts with this EXACT block:

{
  "engines": { "node": "20.x" },
  "scripts": {
    "build": "tsc || true",
    "postbuild": "echo '--- dist tree ---' && (ls -R dist || true)",
    "start": "sh -c 'NODE_ENV=production node dist/server/index.js || node dist/server/index.production.js || node dist/index.js || node dist/index.production.js || node -r ts-node/register -r tsconfig-paths/register server/index.production.ts || node -r ts-node/register -r tsconfig-paths/register server/index.ts || node -r ts-node/register -r tsconfig-paths/register server/index.js'"
  }
}

Notes:
- This tries common output names. If none exist, it runs the TS source directly via ts-node.
- Do NOT add other scripts.

===============================================================================
2) Install minimal helpers for TS fallback (dev only)
===============================================================================
Ensure devDependencies include:
- ts-node
- tsconfig-paths
- typescript (if using TS)

If they’re missing, add to package.json (don’t remove anything else):

"devDependencies": {
  "typescript": "^5.6.3",
  "ts-node": "^10.9.2",
  "tsconfig-paths": "^4.2.0"
}

===============================================================================
3) tsconfig.json: make sure TS files actually compile to dist/ (when build exists)
===============================================================================
Open ROOT tsconfig.json and ensure these keys exist (keep other options intact):

{
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "."
  },
  "include": ["server/**/*.ts", "src/**/*.ts", "index.ts"]
}

===============================================================================
4) Fix the crash cause: add a default export in routes-accounting
===============================================================================
Open server/routes-accounting.ts OR server/routes-accounting.js.
At the VERY END, append ONE line based on your router variable name:

If your router variable is `accountingRoutes`:
  export default accountingRoutes;

If your router variable is `router`:
  export default router;

(Keep any existing named exports. We’re only adding a default so the current
import line `import accountingRoutes from './routes-accounting.js';` works.)

===============================================================================
5) Single listen using Railway's port (skip if already correct)
===============================================================================
In the file that calls app.listen (e.g., server/index.production.ts), ensure:
const port = Number(process.env.PORT) || 3000;
app.listen(port, () => console.log(`ERP running on ${port}`));

Ensure there is EXACTLY ONE app.listen in the project.

===============================================================================
6) Optional: force Node 20 for builders
===============================================================================
Create a file at repo root named: .nvmrc
Content:
20

===============================================================================
7) Railway settings
===============================================================================
In Railway → Service → Settings → Deploy:
- Build Command: npm ci && npm run build
- Start Command: npm run start
- Add env vars (e.g., DATABASE_URL, JWT_SECRET).
- Redeploy. Logs will print '--- dist tree ---' and then start via whichever path exists.

END.
